# 端到端验收用例：SDK append → session commit → Stage2 → Stage3 → 可检索闭环（V0）

> 目的：给实现与测试提供一套“从输入到可检索”的验收路径，避免只验证某个函数而忽略用户实际流程。  
> 范围：只覆盖文本对话（dialog），不覆盖多模态。

---

## 1. Happy Path（标准成功路径）

### 1.1 前置条件

- 已部署 memory 服务端（含 `/ingest/dialog/v1`）  
- 已配置 Qdrant + Neo4j（可用）  
- 已开启 Stage3 可见性门闩（`published=true` 才可检索/可查询）  

### 1.2 输入（SDK 本地 turns）

模拟一个最小会话：

1) `user`：表达偏好（应写入）  
2) `assistant`：回应（通常不写入事实）  
3) `user`：明确保存意图（触发 PinIntent）  

示例 turns（语义示例，不要求字面一致）：

- t0001 user：`我不吃香菜。`
- t0002 assistant：`好的，我会在推荐时避开香菜。`
- t0003 user：`记住这个，很重要。`

### 1.3 操作步骤

1) SDK：append turns（本地，不发网络）  
2) SDK：`session.commit()`（异步）  
3) 服务端：返回 `job_id`（status=RECEIVED）  
4) 服务端后台：
   - Stage0：归档 turns（必成）
   - Stage2：输出 TurnMarkV1（应识别偏好与用户保存意图，生成 PinIntent）
   - Stage3：抽取并写入 Neo4j + Qdrant，最后 publish

### 1.4 验收断言（必须全部满足）

**A. 任务状态**
- job 状态最终为 `COMPLETED`
- attempts：`stage2>=1`、`stage3>=1`，且最后一次无 error

**B. 可见性门闩**
- 在 job 未完成前：
  - `/search` 不应召回本 session 的新内容（或只能通过 debug 参数看到 unpublished）
- 在 job 完成后：
  - `/search` 能召回与“香菜/不吃香菜”相关的证据/知识

**C. 写入结果**
- Qdrant：存在与该偏好相关的向量点，且 `published=true`
- Neo4j：存在对应 Knowledge/Fact 节点与证据链路（source_turn_ids/turn_id 可追溯）
- PinIntent：
  - 写入一个 `user_pinned_note`（或等价 subtype）的 Knowledge/Note
  - 该 Note 必须绑定 `source_turn_ids` 指向目标窗口 turns

---

## 2. Failure Path（Stage3 部分失败 + 重试）

> 目标：验证“对外不出现部分写入”的硬承诺。

### 2.1 故障注入（示意）

制造一种典型失败：Neo4j 写入成功，但 Qdrant 写入失败（网络/超时/权限）。  

### 2.2 期望行为

- job 状态进入 `STAGE3_FAILED`，并安排 `next_retry_at`  
- 归档与 Stage2 产物保留  
- **对外不可见**：
  - Neo4j 内即便存在 `published=false` 的半成品，Graph API 默认查询也不得返回（必须过滤 published）
  - `/search` 必须过滤 `published=true`，不应召回该半成品

### 2.3 重试成功后

- Stage3 重试使用相同幂等 key upsert，不产生重复 node/edge/points  
- publish 完成后，对外一次性可见  

---

## 3. 增量续写（会话重开）

### 3.1 场景

同一个 `session_id` 重开后新增两条 turns：

- t0004 user：`另外，我也不吃葱。`
- t0005 user：`也记住这个。`

### 3.2 验收点

- SDK/服务端 cursor 生效：只提交新增 turns，不重复 ingest t0001~t0003  
- Stage3 写入不重复：原有事实不重复生成；新增事实与 pinned note 正确写入  

