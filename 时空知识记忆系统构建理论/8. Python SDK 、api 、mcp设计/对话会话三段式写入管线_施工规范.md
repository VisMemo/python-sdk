# Stage2 价值标注策略（对话会话写入）施工规范（V0）
（逐 turn 标记 + TTL/重要性/证据等级 + Pin Intent）

> 状态：Draft（可施工）  
> 本文定位：**Stage2 策略说明文档**（只描述“价值标注与治理信号”）  
> 适用前提：服务端 ingest 已接收到标准 `turns[]`（CanonicalTurnV1）；不再需要 Stage1 的“输入格式归一/去噪”。

---

## 0. 为什么需要 Stage2（我们要解决的真问题）

对话记忆的核心矛盾只有一个：**不治理就污染，不过滤就爆炸**。

- 不做价值标注：噪声会进入向量索引与图谱，召回漏斗被垃圾淹没，检索质量会随时间衰退。
- 只做抽取不做治理：事实/知识会无限膨胀，无法做 TTL、重要性、待确认闭环。
- 让 LLM “抄写原文片段”既贵又不可靠：会引入不必要的重试与不可回归风险。

因此 Stage2 的职责被严格限定为：**逐 turn（可选 span）做标记与治理标签**，由程序确定性生成 Stage3 输入。

---

## 1. 本文与其他规范的边界

### 1.1 不再包含 Stage1/Stage3

本文件过去是“三段式管线”文档，但在当前方案中：

- Stage1（输入归一化/去噪）被 SDK/编排层前移：服务端 ingest 收到的就是标准 turns。  
- Stage3（抽取建图写入）在另一份施工规范中定义（见 `客户端SDK_会话提交与重型抽取写入_施工规范_v0.md`）。

所以本文只保留：**Stage2 的策略、数据契约、校验规则与失败语义**。

### 1.2 Stage2 的硬约束（写死）

- Stage2 **不允许**改写/润色/总结 turn 原文；只能输出标记与标签。
- Stage2 **不要求也不允许**输出 `text_exact`（抄写原文片段）。只输出 `turn_id` + `keep/drop` + 可选 `span.start/end`。
- Stage2 输出必须能被程序严格校验；校验失败即视为失败，进入重试。

---

## 2. 输入：CanonicalTurnV1（服务端 ingest 已保证）

Stage2 的输入是标准化后的 `turns[]`，每条至少包含：

```json
{
  "turn_id": "t0001",
  "role": "user|assistant|tool|system",
  "timestamp_iso": "2025-12-21T10:00:00Z",
  "text": "原文文本（UTF-8）",
  "meta": { "any": "..." }
}
```

约束：
- `turn_id` 在 session 内唯一且可排序。
- `text` 为原文。
- `span.start/end` 的索引语义统一为：Python 字符串切片语义（Unicode codepoint 索引）。

---

## 3. 输出：TurnMarkV1（逐 turn 标记）+ PinIntent（用户主动保存意图）

### 3.1 TurnMarkV1（LLM 输出）

Stage2 的主要输出是逐 turn 的标记列表（TurnMarkV1[]）。建议最小字段集：

```json
{
  "turn_id": "t0007",
  "keep": true,
  "span": { "start": 0, "end": 42 },
  "user_triggered_save": false,

  "category": "fact|preference|task|rule|note",
  "subtype": "profile|constraint|commitment|decision|tool_grounded_fact|user_pinned_note",
  "evidence_level": "S0_user_claim|S1_ai_inference|S2_tool_grounded|S3_user_confirmed",
  "requires_confirmation": false,

  "importance": 0.0,
  "ttl_seconds": 0,
  "forget_policy": "permanent|until_changed|temporary",

  "reason": "一句话：为什么保留/为什么丢弃"
}
```

约束：
- `keep=false` 允许出现（用于解释丢弃原因），但不会进入 Stage3。
- `span` 为可选：默认建议 turn-level（不填 span 即“整条 turn 保留”）。仅在确有必要时才用 span。
- `user_triggered_save` 是治理信号：表达“用户明确要求保存”，**不等价于事实为真**。

### 3.2 kept 内容生成（程序确定性，不由 LLM 负责）

程序根据 TurnMarkV1 生成 Stage3 输入：

- `kept_turn_ids`：按 turn 原顺序保留 `keep=true` 的 turn_id
- `kept_spans`：若有 span，则取 `turn.text[start:end]`，否则取整条 `turn.text`
- `filtered_transcript`：将 kept 文本按 turn 顺序拼接（仅供 Stage3 输入与调试，不对外承诺格式稳定）

### 3.3 PinIntent（程序生成，建议落盘）

PinIntent 用于承载“用户主动保存”这类高优先级写入意图，建议由程序从 TurnMarkV1 + 规则生成并落盘（避免让 LLM 直接生成导致不稳定）：

```json
{
  "pin_id": "pin_001",
  "trigger_turn_id": "t0012",
  "target_turn_ids": ["t0008", "t0009", "t0010", "t0011"],
  "reason": "user_explicit_save",
  "importance_boost": 0.9,
  "ttl_seconds": 0,
  "requires_confirmation": false
}
```

---

## 4. 策略：什么该保留、怎么打标签

### 4.1 “值得记”的最小公共语义（默认策略）

默认只把以下内容标为 `keep=true`（其余默认 drop 或短期归档，不进入 Stage3）：

1) **用户稳定信息**：偏好、禁忌、身份、长期背景（S0/S3）  
2) **任务/承诺**：用户要求/AI承诺、截止时间、状态（S0/S3）  
3) **决定与结果**：用户确认的结论（S3 或 S2）  
4) **工具证据事实**：明确来自 tool 结果的事实（S2）

默认不保留（污染源）：
- AI 常识复述、建议性文字、推测性结论（S1）  
- 无工具证据且无用户确认的“事实”

> 注意：这是默认规则，不是铁律；§4.3 用户主动保存是一个必须支持的例外。

### 4.2 TTL / 遗忘策略（默认值，允许 policy 覆盖）

这是产品策略，不允许模型自由发挥；必须写成表并在 prompt 中硬编码。

定义：
- 下表为 **默认值（Default）**：当租户/产品未提供覆盖配置时，Stage2 必须使用这些 fallback 值。
- 允许覆盖（Override）：可由 `tenant/product policy` 覆盖默认值；覆盖必须是显式配置，而不是模型自由发挥。

| category | 默认 forget_policy | ttl_seconds（默认值） | 说明 |
|---|---|---:|---|
| preference | until_changed | 0 | 直到用户改变 |
| rule | permanent | 0 | 用户明确规则/边界 |
| task(open) | temporary | 30d | 未完成任务默认保留 30 天 |
| task(done) | temporary | 7d | 完成后保留一周用于解释 |
| fact(user claim) | temporary | 180d | 用户陈述事实默认半年（可被覆盖） |
| fact(tool grounded) | permanent | 0 | 有证据的事实长期保留 |
| note | temporary | 30d | 备忘/笔记默认 30 天 |

> `ttl_seconds=0` 表示长期；不等价“永不删除”，最终回收由治理层决定。

### 4.3 用户主动保存信号（User-Triggered Save / Pin Intent）

当用户在对话中表达明确的保存意图（例如“记住这个”“这很重要”“请保存这段分析”）：

- 我们必须尊重用户意图：即使目标内容来自 AI 推测（S1），也允许进入写入管线。
- 但必须避免语义污染：**“用户想保存”不等价于“用户确认其为真”。**

因此规则写死如下：

1) Stage2 对目标窗口 turns 标记：  
   - `keep=true`  
   - `user_triggered_save=true`  
   - `importance` 提升到高值（建议 ≥0.9）  
   - `ttl_seconds`/`forget_policy` 采用更强保留策略（长期或更长 TTL）  
2) `evidence_level` 保持真实来源：  
   - AI 推测仍是 `S1_ai_inference`（不要强行升级 `S3_user_confirmed`）  
3) 目标绑定默认规则（确定性）：  
   - 默认目标窗口 `K=4`：以触发指令前最近 `K` 条 turns 为目标，且尽量覆盖最近的 `assistant/tool` turn（如果存在）。  
   - 若目标歧义：对目标 turns 仍可 `user_triggered_save=true`，但必须同时 `requires_confirmation=true`（保存对象需确认）。  
4) Stage3 落库要求（在 Stage3 文档中执行）：  
   - 必须写入一个 `user_pinned_note` 类型的 Knowledge/Note，并绑定 `source_turn_ids=target_turn_ids`，保证可审计与可重试。

---

## 5. 校验规则与失败语义（必须严格）

Stage2 输出必须逐条校验：

- `turn_id` 必须存在于输入 turns  
- `keep` 必须为布尔值  
- 若提供 `span`：`0 <= start < end <= len(turn.text)`（Unicode codepoint 索引）  
- `user_triggered_save`（若出现）必须为布尔值  
- `importance` ∈ [0, 1]，`ttl_seconds >= 0`  
- 枚举字段必须在允许集合内（role/category/subtype/evidence_level/forget_policy）

失败语义（对齐“直到成功”的后台管线）：

- 校验失败：Stage2 视为失败 → 进入重试（记录错误码与 next_retry_at）。  
- Stage2 成功但 `requires_confirmation=true`：允许进入 Stage3，但写入的 Knowledge/Note 必须标注“待确认”（不得当硬事实传播）。

### 5.1 requires_confirmation 的后续闭环（必须明确 owner）

`requires_confirmation=true` 不是“写了就算完”，它意味着需要一个后续闭环，否则这个字段永远只会“写进去，没人捞”。

V0 口径（先施工、后补齐产品闭环）：

- Owner：**上游产品/Agent**（不是记忆服务自动完成）。
- 最小闭环要求：
  1) Retrieval/Agent 侧在召回到 `requires_confirmation=true` 的条目时，必须把它呈现为“待确认项”，引导用户确认/否认；
  2) 用户确认后，上游必须调用记忆编辑接口把该条目从 pending → confirmed（例如通过 `/update` 更新其 `requires_confirmation=false`，并可提升 `evidence_level`/`status` 字段）。

> 说明：闭环的 UI/交互方式属于产品层设计（后续迭代），但 owner 与“如何回写确认结果”必须在施工规范中写死。

---

## 6. 与 MOYAN 当前方案的对齐点（只引用，不重复）

- 会话提交与异步管线：见 `客户端SDK_会话提交与重型抽取写入_施工规范_v0.md`  
- PinIntent 与 `user_pinned_note` 写入语义：以该文档为准（本文提供 Stage2 策略口径）
