# 03. 查询器设计与用例集（Literature-TKG）

> 目标：围绕 Literature-TKG 设计一组标准查询（主要用 Cypher），用于验证图谱在**记忆召回、时序推理、因果与否定逻辑**上的边界能力，同时为 Demo 路演提供脚本。

## 1. 查询设计原则

- 只通过 **公共 Schema 子集** 查询：Character / Faction / Place / Event / TimeSlice / State。  
- 尽量对齐我们在视频记忆场景下的“20 问”类型：  
  - 基础事实；  
  - 时序与状态；  
  - 多跳关系；  
  - 因果与否定。  
- 每类查询都给出：**自然语言问题 + Cypher 模板 + 预期行为**。

## 2. 基础事实查询

### Q1. 某年发生了哪些关键战役？

```cypher
MATCH (t:TimeSlice {year: $year})<-[:OCCURS_AT]-(e:Event)
WHERE e.type = 'Battle'
RETURN e.title AS battle, e.summary AS summary
ORDER BY e.event_id
```

### Q2. 某角色在哪些势力下效力过？

```cypher
MATCH (c:Character {name: $name})-[:BELONGS_TO]->(f:Faction)
RETURN DISTINCT f.name AS faction
```

### Q3. 某地发生过哪些重要事件？

```cypher
MATCH (p:Place {name: $place})<-[:OCCURS_AT]-(e:Event)
RETURN e.title AS event, e.type AS type
ORDER BY e.event_id
```

## 3. 时序与状态查询

### Q4. 某角色的时间线（参与事件序列）

```cypher
MATCH (c:Character {name: $name})<-[:INVOLVES]-(e:Event)-[:OCCURS_AT]->(t:TimeSlice)
RETURN t.year AS year, t.era AS era, e.title AS event, e.summary AS summary
ORDER BY t.year, e.event_id
```

### Q5. 从事件 A 到事件 B 的因果 / 时序路径

```cypher
MATCH (a:Event {event_id: $start_id}),
      (b:Event {event_id: $end_id})
MATCH p = shortestPath((a)-[:NEXT_EVENT|CAUSES*..8]->(b))
RETURN p
```

### Q6. 某人物官职 / 势力归属如何演变？

```cypher
MATCH (c:Character {name: $name})-[:HAS_STATE]->(s:State)-[:RECORDED_AT]->(t:TimeSlice)
WHERE s.property IN ['title', 'faction']
RETURN t.year AS year, t.era AS era, s.property AS prop, s.value AS value
ORDER BY t.year
```

## 4. 多跳关系与间接联系

### Q7. 两个人是通过什么事件认识 / 发生交集的？

```cypher
MATCH (e:Event)-[:INVOLVES]->(c1:Character {name: $name1}),
      (e)-[:INVOLVES]->(c2:Character {name: $name2}),
      (e)-[:OCCURS_AT]->(t:TimeSlice)
RETURN t.year AS year, t.era AS era, e.title AS event, e.summary AS summary
ORDER BY t.year
LIMIT 1
```

### Q8. 某人最常与谁共同出现在事件中？

```cypher
MATCH (me:Character {name: $name})<-[:INVOLVES]-(e:Event)-[:INVOLVES]->(other:Character)
WHERE other <> me
RETURN other.name AS other, count(*) AS co_events
ORDER BY co_events DESC
LIMIT 10
```

### Q9. 某势力在某时间段的主要对手是谁？

```cypher
MATCH (t:TimeSlice)<-[:OCCURS_AT]-(e:Event {type:'Battle'})
WHERE t.year >= $start_year AND t.year <= $end_year
MATCH (e)-[:INVOLVES]->(:Character)-[:BELONGS_TO]->(f1:Faction {name: $faction}),
      (e)-[:INVOLVES]->(:Character)-[:BELONGS_TO]->(f2:Faction)
WHERE f2 <> f1
RETURN f2.name AS opponent, count(*) AS battles
ORDER BY battles DESC
LIMIT 5
```

## 5. 因果与否定逻辑

### Q10. 某战役的直接与间接前因

```cypher
MATCH (e:Event {event_id: $event_id})
MATCH p = (cause:Event)-[:CAUSES*1..4]->(e)
RETURN p
```

### Q11. 某年里“没有参与任何战役”的主要人物？

```cypher
// 参与过战役的人
MATCH (t:TimeSlice {year: $year})<-[:OCCURS_AT]-(e:Event {type:'Battle'})-[:INVOLVES]->(c:Character)
WITH collect(DISTINCT c.name) AS battle_chars

// 所有人物 - 参与过战役的人 = 没有出战的人
MATCH (c2:Character)
WHERE NOT c2.name IN battle_chars
RETURN c2.name AS character
LIMIT 20
```

### Q12. 某时间段内“始终未叛离某势力”的核心角色

```cypher
// 拥有某势力状态的记录
MATCH (c:Character)-[:HAS_STATE]->(s:State {property:'faction', value:$faction})
MATCH (s)-[:RECORDED_AT]->(t:TimeSlice)
WHERE t.year >= $start_year AND t.year <= $end_year
WITH c, collect(DISTINCT t.year) AS years

// 如果该人物在任何年份有其它 faction 状态，则排除
MATCH (c)-[:HAS_STATE]->(s2:State {property:'faction'})
MATCH (s2)-[:RECORDED_AT]->(t2:TimeSlice)
WHERE t2.year >= $start_year AND t2.year <= $end_year
WITH c, years, collect(DISTINCT s2.value) AS factions
WHERE size(factions) = 1  // 只有一个势力
RETURN c.name AS loyal_character
```

## 6. 用法建议

- 在 Neo4j Browser / Bloom 中预置这些查询模板，作为“测试脚本 + Demo 脚本”。  
- 每次对 Schema 或建图策略做改动后，用这一组查询跑一遍：  
  - 如果写法变复杂或结果明显偏离预期，说明 Schema/建图有问题；  
  - 如果查询更简洁、结果更稳定、覆盖更多边界问题，说明演进方向正确。

通过这样的查询集，我们可以在“小说 / 通俗史”的可验证世界里，持续校准 **TKG-Graph-v1.0-Ultimate** 的设计质量。

