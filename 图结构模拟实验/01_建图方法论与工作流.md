# 01. 文本 → Literature-TKG 建图方法论与工作流

> 目标：在不依赖真实 CV/音频 ASR 流水线的前提下，从“小说 / 通俗史书”构造一张带时间轴的时空知识图谱；其中**人物对白视为理想化的 ASR（UtteranceEvidence）**，用于验证 **TKG-Graph-v1.0-Ultimate** 的图设计是否合理。

## 1. 实验范围与约束

- 材料类型：长篇叙事文本，时间顺序较明确（如三国、明史）。  
- 版本：采用 **TKG-Graph-v1.0-Ultimate** 的一个 **Literature 子集 Schema**：  
  - 必选：Character / Faction / Place / Event / TimeSlice / State；  
  - 可选：**UtteranceEvidence（对白 → 理想化 ASR）**，但不引入视觉 Evidence / VLM。
- 设计原则：
  - **事件是主角**：一切围绕 Event 链接人物、势力、地点与时间。
  - **时间轴清晰**：所有 Event 必须绑定到 TimeSlice（至少年级别），支持 `NEXT_EVENT` 链。
  - **身份唯一**：人物以 `Character` 节点为全局身份，章节内提到的别名在属性中归并。

## 2. Literature-TKG 子集 Schema（实验版）

节点类型：
- `Character`：人物实体（映射到 Entity(Person)）。  
  - 关键属性：`name`, `aliases[]`, `era_range`, `notes`.  
- `Faction`：势力 / 阵营（映射到 Entity(Org)）。  
  - 属性：`name`, `type` (kingdom/clan/army)。  
- `Place`：地点 / 城池 / 战场（映射到 Region/Place）。  
  - 属性：`name`, `kind` (city/region/battlefield)。  
- `TimeSlice`：时间片，实验版推荐以“年”为粒度。  
  - 属性：`year`, `era`, `label`（如“建安五年(200)”）。  
- `Event`：叙事事件（战役、会议、结盟、任命、谋杀…）。  
  - 属性：`event_id`, `title`, `event_type`, `summary`, `source_text_ref`。  
- `State`（可选）：人物 / 势力的长期状态（官职、归属、联盟关系）。  
  - 属性：`state_id`, `subject`, `property`, `value`, `valid_from/to?`。  
- `UtteranceEvidence`（可选）：对白/引号内发言（映射到 UtteranceEvidence，作为**理想 ASR 文本**）。  
  - 属性：`utterance_id`, `raw_text`, `speaker_name`, `time_origin='logical'`, `source='literature'`。

关系类型：
- `OCCURS_AT`：`Event → TimeSlice` / `Event → Place`。  
- `INVOLVES`：`Event → Character / Faction`，带 `role` (commander/advisor/ally)。  
- `BELONGS_TO`：`Character → Faction`（长期隶属）。  
- `NEXT_EVENT`：事件时间顺序链（同一 story line）。  
- `CAUSES`：重要因果链条（例如“官渡胜利 → 袁绍势力衰落”）。  
- `HAS_STATE`：`Character/Faction → State`。  
- `TRANSITIONS_TO`：`State → State`（状态变更）。  
- `SPOKEN_BY`（可选）：`UtteranceEvidence → Character`（谁说的这句话）。  
- `SUPPORTED_BY`（可选）：`Event → UtteranceEvidence`（事件语义由哪些对白支撑）。  
- `TEMPORALLY_CONTAINS`（可选）：`TimeSlice → UtteranceEvidence`（对白发生在什么时间片，时间源为“逻辑时间”）。

## 3. AI 建图工作流（文本 → JSON）

整体思路：**章节切片 → 事件抽取 → 角色/势力/地点抽取与对齐 → 时间轴归档 → 输出标准 JSON**。

### 3.1 文本切片策略

- 切片单位：
  - 历史年表：按“年”或“关键战役”分；  
  - 小说：按“章节 / 情节块（场景）”分。  
- 每个切片（Scene）对应一份 LLM 输入，输出若干 Event。

### 3.2 LLM 输出 JSON Schema 规范

统一的 JSON 模板（示例，含可选对白）：

```jsonc
{
  "timeslice": {
    "year": 200,
    "era": "建安五年",
    "label": "建安五年(200)"
  },
  "events": [
    {
      "event_id": "jianan5_guandu_battle",
      "title": "官渡之战爆发",
      "event_type": "Battle",
      "summary": "曹操与袁绍在官渡展开决战。",
      "place": {
        "name": "官渡",
        "kind": "battlefield"
      },
      "participants": [
        { "name": "曹操", "role": "commander", "faction": "曹魏", "aliases": ["孟德"] },
        { "name": "袁绍", "role": "commander", "faction": "袁绍集团" }
      ],
      "states": [
        {
          "subject": "曹操",
          "property": "power_balance",
          "value": "rising"
        }
      ],
      "utterances": [
        {
          "utterance_id": "jianan5_guandu_battle_u1",
          "speaker": "曹操",
          "raw_text": "兵贵神速，不可与之久持。",
          "note": "视为理想化 ASR 文本，time_origin='logical'"
        }
      ],
      "caused_by": ["jianan4_yuanshao_south_campaign"],
      "causes": ["jianan5_yuan_army_defeated"],
      "sequence_after": "jianan5_preparation_phase",
      "source_span": {
        "chapter": "官渡之战",
        "start_offset": 1234,
        "end_offset": 2345
      }
    }
  ]
}
```

约束：
- 每个 `events[]` 元素必须有：`event_id`, `title`, `event_type`, `place`, 至少 1 名参与者。  
- `event_id` 由“era + keyword + 局部序号”规则生成，AI 负责给出稳定字符串。  
- `caused_by` / `causes` / `sequence_after` 中引用的是其他 `event_id`，允许后续跨文件补全。

### 3.3 LLM Prompt 结构（示意）

核心提示结构：

1. 提供 **固定的 Schema 说明**：节点/字段含义 + JSON 模板。  
2. 输入：  
   - 当前文本片段（scene）；  
   - 已知人物 / 势力 / 地点列表（作为先验字典，减少幻觉）；  
   - 所属大时间段（例如“建安五年左右”）。  
3. 输出要求：  
   - 必须输出合法 JSON；  
   - 所有事件必须填年份（不确定可用 `approx_year` 字段）；  
   - 连贯事件要用 `sequence_after` 串起来。

### 3.4 多轮收敛策略

- 第 1 轮：只抽 `events[]` 基本字段（不做 CAUSES/State）。  
- 第 2 轮：在已知 `event_id` 集合的前提下，再跑一轮“因果和状态补全”任务：  
  - 输入：汇总事件列表 + 段落文本；  
  - 输出：为每个事件补 `caused_by` / `causes` / `states[]`。  
- 所有 JSON 存入 `literature_events/` 目录，作为建图“原始记录”，不直接改图。

## 4. 人工/半自动审核建议

- 至少抽样检查：  
  - Event 粒度是否合适（过细/过粗）；  
  - 关键战役是否缺失；  
  - 人物名、势力名是否统一（曹操=曹孟德=孟德 归并）。  
- 可以引入简单的 Python 校验脚本：  
  - 校验 JSON schema；  
  - 校验引用的 `event_id` 是否存在；  
  - 导出“人物出现频次”、“事件时间分布”等粗指标。

## 5. 小结

这份方法论解决的问题是：
- 把“文本 → 图”拆解为“文本 → JSON → 图”，实现理论 Schema 与 AI 建图流程的解耦；  
- 使得我们可以在不管 CV/ASR 的情况下，先验证 Literature-TKG 的结构是否能回答真实的复杂问题（多跳、因果、否定逻辑）。  

后续步骤：见 `02_JSON_to_TKG_导入算法与Neo4j写入.md`。
